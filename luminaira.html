<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>LUMINAIRA</title>
    <link rel="icon" href="luminairaicon.png" type="image/png">
    <link rel="apple-touch-icon" href="luminairaicon.png">
    <meta name="theme-color" content="#0f0f23">
    <meta name="color-scheme" content="dark">

    <style>
        /* --- Global Styles & Variables --- */
        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --bg-dark: #0f0f23;
            --bg-card: #1a1a2e;
            --bg-input: #16213e;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --border: #54637a;
            --code-bg: #0d0d1f;
            --shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            --glow: 0 0 20px rgba(99, 102, 241, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: -webkit-fill-available;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #16213e 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow-x: hidden;
        }

        /* --- Background Animation --- */
        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .floating-orb {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary), var(--primary-light));
            opacity: 0.1;
            animation: float 6s ease-in-out infinite;
        }

        .floating-orb:nth-child(1) {
            width: 200px;
            height: 200px;
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .floating-orb:nth-child(2) {
            width: 150px;
            height: 150px;
            top: 60%;
            right: 10%;
            animation-delay: 2s;
        }

        .floating-orb:nth-child(3) {
            width: 100px;
            height: 100px;
            bottom: 10%;
            left: 50%;
            animation-delay: 4s;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }

            50% {
                transform: translateY(-20px) rotate(180deg);
            }
        }

        /* --- Layout & Main Components --- */
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: -webkit-fill-available;
        }

        .header {
            text-align: center;
            margin-bottom: 1rem;
            flex-shrink: 0;
        }

        .header-icon {
            display: block;
            margin: 0 auto 1rem;
            width: 80px;
            height: auto;
        }

        .title {
            font-size: clamp(2rem, 5vw, 2.5rem);
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
            animation: glow 2s ease-in-out infinite alternate;
            cursor: pointer;
        }

        .highlight-ai {
            background: linear-gradient(135deg, #8488fd, #8488fd);
            /* slightly lighter than var(--primary-light) */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }


        @keyframes glow {
            from {
                filter: drop-shadow(0 0 5px rgba(99, 102, 241, 0.3));
            }

            to {
                filter: drop-shadow(0 0 15px rgba(99, 102, 241, 0.6));
            }
        }

        .subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 300;
        }

        .model-info {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            background: var(--bg-card);
            border-radius: 24px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            overflow: hidden;
            position: relative;
        }

        .chat-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        /* --- Chat Output Area --- */
        .output-area {
            flex-grow: 1;
            padding: 1.5rem;
            overflow-y: auto;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(to bottom, transparent, rgba(99, 102, 241, 0.02));
            scroll-behavior: auto;
        }

        .output-area::-webkit-scrollbar {
            width: 8px;
        }

        .output-area::-webkit-scrollbar-track {
            background: var(--bg-input);
        }

        .output-area::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        /* --- Messages --- */
        .message {
            display: flex;
            margin-bottom: 1.5rem;
            max-width: 100%;
            animation: messageSlide 0.5s ease-out;
            position: relative;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-content-wrapper {
            flex: 1;
            position: relative;
            min-width: 0;
            /* Prevents flex item from pushing container width */
        }

        .message-content {
            padding: 0.75rem 1rem;
            border-radius: 16px;
            overflow-wrap: break-word;
            /* Modern property to break long words and prevent overflow */
            line-height: 1.6;
        }

        .message-content a {
            color: var(--primary-light);
            text-decoration: underline;
            text-decoration-color: rgba(129, 140, 248, 0.5);
            transition: color 0.2s ease, text-decoration-color 0.2s ease;
        }

        .message-content a:hover {
            color: #fff;
            text-decoration-color: #fff;
        }


        .user-message {
            margin-left: auto;
            flex-direction: row-reverse;
        }

        .user-message .message-content {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3);
        }

        .ai-message {
            margin-right: auto;
        }

        .ai-message .message-content {
            background: var(--bg-input);
            border: 1px solid var(--border);
        }

        .streaming-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--primary);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.4;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* --- Copy Button for Messages --- */
        .message-actions {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 10;
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .message:hover .message-actions {
            opacity: 1;
        }

        .ai-message .message-content-wrapper:has(pre) .message-actions {
            display: none;
        }

        .copy-message-btn {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-size: 0.75rem;
        }

        .copy-message-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .copy-message-btn.copied {
            background-color: #22c55e;
            color: white;
            border-color: #22c55e;
        }

        /* --- Input Section --- */
        .input-section {
            padding: 1rem;
            background: linear-gradient(to top, rgba(26, 26, 46, 0.8), transparent);
            flex-shrink: 0;
        }

        .input-container {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .prompt-input {
            flex: 1;
            background: var(--bg-input);
            border: 2px solid var(--border);
            border-radius: 16px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: inherit;
            resize: none;
            overflow-y: hidden;
            transition: all 0.3s ease;
            line-height: 1.5;
            /* Explicitly set the height */
            height: 48px;
            max-height: 120px;
            /* Keep this for when the textarea grows */
        }

        .prompt-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: var(--glow);
            transform: translateY(-2px);
        }

        .prompt-input::placeholder {
            color: var(--text-secondary);
        }

        .send-button {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border: none;
            border-radius: 50%;
            /* Make width and height identical to the input box's initial height */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3);
            flex-shrink: 0;
        }

        .send-button:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 12px 40px rgba(99, 102, 241, 0.4);
        }

        .send-button:active:not(:disabled) {
            transform: translateY(0) scale(1);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* --- SPINNER STYLES --- */
        .send-button .send-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-button .loader {
            display: none;
        }

        .send-button.loading .send-icon {
            display: none;
        }

        .send-button.loading .loader {
            display: block;
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .send-button.loading:not(:disabled) {
            cursor: pointer;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* --- Status Bar --- */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--bg-input);
            border-top: 1px solid var(--border);
            font-size: 0.8rem;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.error {
            background: #ef4444;
        }

        .status-dot.processing {
            background: #f59e0b;
        }

        .status-dot.cancelled {
            background: #a1a1aa;
            animation: none;
        }

        .response-time {
            margin-left: 0.5rem;
        }

        /* --- Empty State & Prompt Suggestions --- */
        .empty-state {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .empty-state-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            opacity: 0.8;
        }

        .empty-state h2 {
            color: var(--text-primary);
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        .prompt-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1.5rem;
            justify-content: center;
        }

        .suggestion-btn {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.875rem;
        }

        .suggestion-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }

        /* --- Markdown and Code Block Styles --- */
        .message-content pre {
            background-color: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin: 1rem 0;
            position: relative;
            font-size: 0.9rem;
        }

        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
            font-size: 0.875rem;
            color: var(--text-secondary);
            border-top-left-radius: 11px;
            border-top-right-radius: 11px;
        }

        .copy-code-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .copy-code-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .copy-code-btn.copied {
            background-color: #22c55e;
            color: white;
            border-color: #22c55e;
        }

        .message-content code {
            font-family: 'Fira Code', 'Courier New', monospace;
        }

        .message-content pre code {
            display: block;
            padding: 1rem;
            overflow-x: auto;
            color: #d1d5db;
        }

        .message-content :not(pre)>code {
            background-color: var(--bg-input);
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
        }

        .message-content ul,
        .message-content ol {
            padding-left: 1.5rem;
            margin: 1rem 0;
        }

        .message-content li {
            margin-bottom: 0.5rem;
        }

        .message-content strong {
            font-weight: 700;
        }

        .message-content em {
            font-style: italic;
        }

        .message-content p {
            margin: 1rem 0;
        }

        .message-content p:first-child {
            margin-top: 0;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        /* --- CSS Styles for Headings --- */
        .message-content h1,
        .message-content h2,
        .message-content h3,
        .message-content h4,
        .message-content h5,
        .message-content h6 {
            color: var(--primary-light);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            line-height: 1.3;
        }

        .message-content h1 {
            font-size: 1.75em;
        }

        .message-content h2 {
            font-size: 1.5em;
        }

        .message-content h3 {
            font-size: 1.25em;
        }

        .message-content p+h1,
        .message-content p+h2,
        .message-content ul+h2,
        .message-content ol+h2 {
            margin-top: 2rem;
        }

        /* --- Desktop-Specific Adjustments --- */
        @media (min-width: 769px) {
            .container {
                padding: 2rem;
            }

            .header {
                margin-bottom: 2rem;
            }

            .header-icon {
                width: 100px;
            }

            .title {
                font-size: 3.5rem;
            }

            .subtitle {
                font-size: 1.1rem;
            }

            .output-area {
                padding: 2rem;
            }

            .message-content {
                padding: 1rem 1.5rem;
            }

            .input-section {
                padding: 1.5rem;
            }

            .input-container {
                gap: 1rem;
            }

            .prompt-input {
                padding: 1rem 1.5rem;
                max-height: 200px;
            }

            .send-button {
                width: 52px;
                height: 52px;
            }

            .status-bar {
                padding: 0.75rem 1.5rem;
                font-size: 0.875rem;
            }
        }

        /* --- Overlay Styles --- */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s 0.3s, opacity 0.3s ease;
        }

        .overlay.visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .overlay-content {
            background-color: var(--bg-card);
            padding: 2rem;
            border-radius: 16px;
            max-width: 600px;
            text-align: center;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            cursor: default;
        }

        .overlay-content #dynamicModelName {
            color: var(--primary-light);
            font-weight: 500;
        }

        .overlay.visible .overlay-content {
            transform: scale(1);
        }

        /* --- Confirmation Dialog Styles --- */
        .confirmation-dialog {
            background-color: var(--bg-card);
            padding: 2rem;
            border-radius: 16px;
            text-align: center;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            cursor: default;
        }

        .overlay.visible .confirmation-dialog {
            transform: scale(1);
        }

        .confirmation-dialog p {
            font-size: 1.25rem;
            color: var(--text-primary);
            margin: 0 0 1.5rem 0;
        }

        .confirmation-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .confirm-btn {
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .confirm-btn.yes {
            background-color: #ef4444;
            /* Red */
            color: white;
        }

        .confirm-btn.yes:hover {
            background-color: #dc2626;
            /* Darker Red */
        }

        .confirm-btn.no {
            background-color: var(--border);
            color: var(--text-primary);
        }

        .confirm-btn.no:hover {
            background-color: #4b5563;
            /* Gray */
        }

        /* --- New Chat/Reload Button --- */
        .reload-button {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border: none;
            border-radius: 50%;
            /* Make width and height identical to the input box's initial height */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3);
            font-size: 28px;
            font-weight: 300;
            line-height: 1;
            flex-shrink: 0;
        }

        .reload-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 12px 40px rgba(99, 102, 241, 0.4);
        }

        .reload-button:active {
            transform: translateY(0) scale(1);
        }

        @media (min-width: 769px) {
            .reload-button {
                width: 52px;
                height: 52px;
                font-size: 32px;
            }
        }
    </style>
</head>

<body>
    <div class="background-animation">
        <div class="floating-orb"></div>
        <div class="floating-orb"></div>
        <div class="floating-orb"></div>
    </div>

    <div id="overlay" class="overlay">
        <div class="overlay-content">
            <p>LUMINAIRA is a small personal AI assistant side project I created using the <span
                    id="dynamicModelName"></span> model, running entirely locally in LM Studio on a 2013 Dell Latitude
                E6440 (i5-4310M, 8 GB DDR3 SDRAM), which is available for interaction via this webpage. The old meets
                the new ✨</p>
        </div>
    </div>

    <div id="cancelConfirmationOverlay" class="overlay">
        <div class="confirmation-dialog">
            <p>Stop response?</p>
            <div class="confirmation-buttons">
                <button id="confirmCancelBtn" class="confirm-btn yes">YES</button>
                <button id="denyCancelBtn" class="confirm-btn no">NO</button>
            </div>
        </div>
    </div>

    <div class="container">
        <header class="header">
            <img src="luminairaicon.png" alt="Luminaira Icon" class="header-icon">
            <h1 class="title" id="clickableTitle">LUMIN<span class="highlight-ai">AI</span>RA</h1>
            <p class="subtitle"></p>
            <p class="model-info" id="modelInfo"></p>
        </header>

        <main class="chat-container">
            <div class="output-area" id="outputArea" aria-live="polite">
                <div class="empty-state" id="emptyState">
                    <div class="empty-state-icon">✨</div>
                    <h2>Start a new conversation</h2>
                    <p>What can I help you with today?</p>
                    <div class="prompt-suggestions" id="promptSuggestions">
                    </div>
                </div>
            </div>

            <section class="input-section">
                <div class="input-container">
                    <button class="reload-button" id="reloadButton" aria-label="Reload Page"
                        title="Start New Chat">&#43;</button>
                    <textarea class="prompt-input" id="promptInput" placeholder="" rows="1"></textarea>
                    <button class="send-button" id="sendButton" aria-label="Send Message">
                        <span class="send-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path d="M7 11L12 6L17 11M12 18V7" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                        </span>
                        <span class="loader"></span>
                    </button>
                </div>
            </section>

            <footer class="status-bar">
                <div class="status-indicator">

                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Ready</span>
                    <span id="responseTime" class="response-time"></span>
                </div>
                <div id="tokenCount">0 tokens</div>
            </footer>
        </main>

    </div>

    <script>
        // Your JavaScript remains the same. The element IDs are preserved.
        document.addEventListener('DOMContentLoaded', () => {
            const chat = new LLMChat();
            const modelName = chat.getModelName();

            const clickableTitle = document.getElementById('clickableTitle');
            const overlay = document.getElementById('overlay');
            const dynamicModelNameSpan = document.getElementById('dynamicModelName');
            const reloadButton = document.getElementById('reloadButton');

            if (dynamicModelNameSpan) {
                dynamicModelNameSpan.textContent = modelName;
            }

            clickableTitle.addEventListener('click', () => {
                overlay.classList.add('visible');
            });

            overlay.addEventListener('click', (e) => {


                overlay.classList.remove('visible');

            });

            if (reloadButton) {
                reloadButton.addEventListener('click', () => {
                    location.reload(true);
                });
            }
        });

        class LLMChat {
            #config = {
                apiUrl: 'https://2f28-174-88-255-33.ngrok-free.app/v1/chat/completions',
                model: 'qwen/qwen3-1.7b',
                bearerToken: 'lm-studio',
systemPrompt: 'You are a highly capable, reliable, and expert AI assistant. Your purpose is to provide clear, accurate, and complete responses to user queries. Always prioritize precision and brevity. Avoid unnecessary conversational elements such as disclaimers, apologies, or references to being an AI unless the user explicitly asks for them. Maintain a neutral, professional, and respectful tone at all times. If a query is outside your knowledge, state this clearly and suggest practical ways the user might find the answer.'
            };

            #elements = {};
            #isStreaming = false;
            #messages = [];
            #abortController = null;

            // --- Wake Lock ---
            #wakeLock = null;

            constructor() {
                this.#initializeElements();
                this.#bindEvents();
                this.#updateStatus('Ready', 'success');
            }

            getModelName() {
                return this.#config.model;
            }

            #initializeElements() {
                this.#elements = {
                    outputArea: document.getElementById('outputArea'),
                    promptInput: document.getElementById('promptInput'),
                    sendButton: document.getElementById('sendButton'),
                    statusDot: document.getElementById('statusDot'),
                    statusText: document.getElementById('statusText'),
                    tokenCount: document.getElementById('tokenCount'),
                    emptyState: document.getElementById('emptyState'),
                    promptSuggestions: document.getElementById('promptSuggestions'),
                    modelInfo: document.getElementById('modelInfo'),
                    responseTime: document.getElementById('responseTime'),
                    cancelConfirmationOverlay: document.getElementById('cancelConfirmationOverlay'),
                    confirmCancelBtn: document.getElementById('confirmCancelBtn'),
                    denyCancelBtn: document.getElementById('denyCancelBtn')
                };
            }

            #bindEvents() {
                this.#elements.sendButton.addEventListener('click', () => {
                    if (this.#isStreaming) {
                        this.#elements.cancelConfirmationOverlay.classList.add('visible');
                    } else {
                        this.#sendMessage();
                    }
                });

                this.#elements.promptInput.addEventListener('keydown', (e) => {
                    const isMobile = window.matchMedia('(pointer: coarse)').matches;
                    if (e.key === 'Enter' && !e.shiftKey && !isMobile) {
                        e.preventDefault();
                        this.#sendMessage();
                    }
                });
                this.#elements.promptInput.addEventListener('input', () => {
                    this.#updateTokenCount();
                    this.#autoResizeTextarea();
                });

                this.#elements.outputArea.addEventListener('click', (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;

                    if (button.classList.contains('copy-code-btn')) {
                        this.#handleCopyCodeClick(button);
                    }
                    if (button.classList.contains('copy-message-btn')) {
                        this.#handleCopyMessageClick(button);
                    }
                });

                if (this.#elements.promptSuggestions) {
                    this.#elements.promptSuggestions.addEventListener('click', (e) => {
                        if (e.target.matches('.suggestion-btn')) {
                            this.#elements.promptInput.value = e.target.textContent;
                            this.#elements.promptInput.focus();
                            this.#updateTokenCount();
                            this.#autoResizeTextarea();
                        }
                    });
                }

                this.#elements.confirmCancelBtn.addEventListener('click', () => this.#cancelStream());

                this.#elements.denyCancelBtn.addEventListener('click', () => {
                    this.#elements.cancelConfirmationOverlay.classList.remove('visible');
                });

                this.#elements.cancelConfirmationOverlay.addEventListener('click', (e) => {
                    if (e.target === this.#elements.cancelConfirmationOverlay) {
                        this.#elements.cancelConfirmationOverlay.classList.remove('visible');
                    }
                });

                // Re-acquire wake lock if tab becomes visible again
                document.addEventListener('visibilitychange', () => {
                    if (this.#wakeLock !== null && document.visibilityState === 'visible') {
                        this.#requestWakeLock();
                    }
                });
            }

            #scrollToInputArea() {
                // Scrolls the main prompt input textarea into the view.
                // This provides a consistent focal point for the user after submitting a message.
                setTimeout(() => {
                    // 'end' aligns the bottom of the input with the bottom of the visible area.
                    this.#elements.statusText.scrollIntoView({ behavior: 'auto', block: 'end' });
                }, 0);
            }

            #cancelStream() {
                if (this.#abortController) {
                    this.#abortController.abort();
                }
                this.#elements.cancelConfirmationOverlay.classList.remove('visible');
            }

            #autoResizeTextarea() {
                this.#elements.promptInput.style.height = 'auto';
                this.#elements.promptInput.style.height = `${this.#elements.promptInput.scrollHeight}px`;
            }

            #updateTokenCount() {
                const text = this.#elements.promptInput.value;
                const estimatedTokens = Math.ceil(text.length / 4);
                this.#elements.tokenCount.textContent = `${estimatedTokens} tokens`;
            }

            #updateStatus(text, type = 'success') {
                this.#elements.statusText.textContent = text;
                this.#elements.statusDot.className = `status-dot ${type}`;
            }

            #addMessage(content, role) {
                if (this.#elements.emptyState) {
                    this.#elements.emptyState.remove();
                    this.#elements.emptyState = null;
                }

                const messageWrapper = document.createElement('div');
                messageWrapper.className = `message ${role}-message`;

                const renderedContent = this.#renderMarkdown(content);

                const finalContent = role === 'user'
                    ? `<p>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`
                    : renderedContent;

                messageWrapper.innerHTML = `
                    <div class="message-content-wrapper">
                        <div class="message-actions">
                            <button class="copy-message-btn" title="Copy message">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            </button>
                        </div>
                        <div class="message-content">${finalContent}</div>
                    </div>
                `;

                this.#elements.outputArea.appendChild(messageWrapper);

                // --- MODIFICATION: Scroll to see the new message. This is the only place auto-scroll is triggered. ---
                this.#scrollToInputArea();

                return messageWrapper;
            }

            #updateStreamingMessage(messageWrapper, content, isComplete = false) {
                let renderedContent = this.#renderMarkdown(content);
                if (!isComplete && content.length > 0) {
                    renderedContent += '<span class="streaming-indicator"></span>';
                }

                const contentDiv = messageWrapper.querySelector('.message-content');

                // --- MODIFICATION: Auto-scrolling logic has been removed from this function. ---
                // Scrolling now only happens once when #addMessage is called, preventing the
                // view from jumping down while the AI response is streaming.

                if (contentDiv) {
                    contentDiv.innerHTML = renderedContent;
                }
            }


            async #sendMessage() {
                const prompt = this.#elements.promptInput.value.trim();
                if (!prompt || this.#isStreaming) return;

                this.#abortController = new AbortController();
                let aiMessageWrapper = null;
                let fullResponse = '';
                let startTime;

                this.#toggleLoading(true);
                this.#requestWakeLock();
                this.#updateStatus('Sending...', 'processing');
                this.#elements.responseTime.textContent = '';

                this.#addMessage(prompt, 'user');
                this.#messages.push({ role: 'user', content: prompt });

                this.#elements.promptInput.value = '';
                this.#autoResizeTextarea();
                this.#updateTokenCount();

                try {
                    startTime = performance.now();

                    const response = await fetch(this.#config.apiUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.#config.bearerToken}`,
                            'Content-Type': 'application/json'
                        },
                        signal: this.#abortController.signal,
                        body: JSON.stringify({
                            model: this.#config.model,
                            messages: [
                                { role: 'system', content: this.#config.systemPrompt },
                                ...this.#messages
                            ],
                            temperature: 0.7,
                            top_k: 20,
                            top_p: 0.8,
                            min_p: 0.01,
                            enable_thinking: false,
                            stream: true,
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: 'An unknown HTTP error occurred.' }));
                        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                    }

                    this.#updateStatus('Receiving...', 'processing');
                    aiMessageWrapper = this.#addMessage('', 'ai');

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6).trim();
                                if (data === '[DONE]') continue;
                                try {
                                    const parsed = JSON.parse(data);
                                    const delta = parsed.choices?.[0]?.delta?.content;
                                    if (delta) {
                                        fullResponse += delta;
                                        this.#updateStreamingMessage(aiMessageWrapper, fullResponse);
                                    }
                                } catch (e) {
                                    console.error("Could not parse a chunk of the stream:", data);
                                }
                            }
                        }
                    }

                    if (fullResponse.trim() === '') {
                        throw new Error("Empty response. Prompt too long or unknown error.");
                    }

                    const endTime = performance.now();
                    const duration = ((endTime - startTime) / 1000).toFixed(2);
                    this.#elements.responseTime.textContent = `(responded in ${duration}s)`;

                    this.#updateStreamingMessage(aiMessageWrapper, fullResponse, true);
                    this.#messages.push({ role: 'assistant', content: fullResponse });
                    this.#updateStatus('Ready', 'success');

                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('Fetch aborted by user.');
                        this.#updateStatus('Cancelled', 'cancelled');
                        if (aiMessageWrapper) {
                            this.#updateStreamingMessage(aiMessageWrapper, fullResponse, true);
                        }
                        if (fullResponse) {
                            this.#messages.push({ role: 'assistant', content: fullResponse });
                        }
                    } else {
                        console.error('Error:', error);
                        this.#addMessage(`**Error:**\n\`\`\`\n${error.message}\n\`\`\``, 'ai');
                        this.#updateStatus('Error', 'error');
                        this.#elements.responseTime.textContent = '';
                    }
                } finally {
                    this.#toggleLoading(false);
                    this.#releaseWakeLock();
                    this.#abortController = null;
                }
            }
            #toggleLoading(isLoading) {
                this.#isStreaming = isLoading;
                this.#elements.promptInput.disabled = isLoading;
                this.#elements.sendButton.classList.toggle('loading', isLoading);
            }

            // --- Screen Wake Lock API Implementation ---

            async #requestWakeLock() {
                if ('wakeLock' in navigator) {
                    try {
                        this.#wakeLock = await navigator.wakeLock.request('screen');
                        this.#wakeLock.addEventListener('release', () => {
                            console.log('Screen Wake Lock released automatically.');
                        });
                        console.log('Screen Wake Lock acquired.');
                    } catch (err) {
                        console.error(`Failed to acquire Wake Lock: ${err.name}, ${err.message}`);
                    }
                } else {
                    console.warn('Wake Lock API not supported.');
                }
            }

            #releaseWakeLock() {
                if (this.#wakeLock !== null) {
                    this.#wakeLock.release();
                    this.#wakeLock = null;
                    console.log('Screen Wake Lock released.');
                }
            }

            #renderMarkdown(text) {
                let html = text
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .trim();

                // Process Markdown-style links: [text](url)
                html = html.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

                // Process bare URLs
                const bareUrlRegex = /(?<!href=")(?<!">)\b(https?:\/\/[^\s<]+)/g;
                html = html.replace(bareUrlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');

                html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                    const language = lang || 'plaintext';
                    const escapedCode = code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `
                        <pre><div class="code-block-header"><span>${language}</span><button class="copy-code-btn">Copy</button></div><code class="language-${language}">${escapedCode}</code></pre>
                    `;
                });

                const lines = html.split('\n');
                let inList = null;
                let processedHtml = '';

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];

                    if (line.startsWith('<pre>')) {
                        const preEnd = html.indexOf('</pre>', html.indexOf(line));
                        const block = html.substring(html.indexOf(line), preEnd + 6);
                        processedHtml += block;
                        const lineCount = block.split('\n').length;
                        i += lineCount - 1;
                        inList = null;
                        continue;
                    }

                    line = line.replace(/\*\*([^\*]+)\*\*|__([^__]+)__/g, '<strong>$1$2</strong>');
                    line = line.replace(/\*([^\*]+)\*|_([^_]+)_/g, '<em>$1$2</em>');
                    line = line.replace(/`([^`]+)`/g, '<code>$1</code>');

                    if (line.match(/^#+\s/)) {
                        if (inList) {
                            processedHtml += `</${inList}>`;
                            inList = null;
                        }
                        const match = line.match(/^(#+)\s(.*)/);
                        const level = Math.min(match[1].length, 6);
                        const text = match[2];
                        processedHtml += `<h${level}>${text}</h${level}>`;
                    }
                    else if (/^\s*[\-\*]\s/.test(line)) {
                        if (inList !== 'ul') {
                            processedHtml += (inList ? `</${inList}>` : '') + '<ul>';
                            inList = 'ul';
                        }
                        processedHtml += `<li>${line.replace(/^\s*[\-\*]\s/, '')}</li>`;
                    }
                    else if (/^\s*\d\.\s/.test(line)) {
                        if (inList !== 'ol') {
                            processedHtml += (inList ? `</${inList}>` : '') + '<ol>';
                            inList = 'ol';
                        }
                        processedHtml += `<li>${line.replace(/^\s*\d\.\s/, '')}</li>`;
                    }
                    else {
                        if (inList) {
                            processedHtml += `</${inList}>`;
                            inList = null;
                        }
                        if (line.trim().length > 0) {
                            processedHtml += `<p>${line}</p>`;
                        }
                    }
                }
                if (inList) processedHtml += `</${inList}>`;

                return processedHtml;
            }

            #handleCopyMessageClick(button) {
                const messageContent = button.closest('.message-content-wrapper').querySelector('.message-content');
                if (!messageContent) return;

                navigator.clipboard.writeText(messageContent.innerText).then(() => {
                    const originalContent = button.innerHTML;
                    button.innerHTML = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                        button.classList.remove('copied');
                    }, 2000);
                });
            }

            #handleCopyCodeClick(button) {
                const pre = button.closest('pre');
                const code = pre.querySelector('code');
                navigator.clipboard.writeText(code.innerText).then(() => {
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                });
            }
        }
    </script>
</body>

</html>