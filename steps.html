<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gem Step Counter</title>
    <style>
        body {
            background-color: #000080; /* Dark Blue */
            color: #FFD700; /* Gold */
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        .container {
            width: 100%;
            max-width: 400px; /* Max width for larger mobile screens */
        }

        .metric {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .metric h2 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.2em;
            color: #FFD700; /* Gold */
        }

        .metric p {
            margin: 0;
            font-size: 2em;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            justify-content: space-around; /* Distribute buttons evenly */
            width: 100%;
            margin-top: 20px;
        }

        button {
            background-color: #FFD700; /* Gold */
            color: #000080; /* Dark Blue */
            border: none;
            padding: 15px 0; /* Vertical padding, horizontal will be handled by flex-basis */
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            flex-basis: 45%; /* Each button takes up 45% of the container width */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: #e6c300; /* Darker Gold */
        }

        button:active {
            transform: scale(0.98);
        }

        #permissionMessage {
            color: #FFD700;
            margin-top: 15px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="metric">
            <h2>Steps</h2>
            <p id="stepCount">0</p>
        </div>

        <div class="metric">
            <h2>Distance (km)</h2>
            <p id="distanceKm">0.000</p>
        </div>

        <div class="metric">
            <h2>Distance (miles)</h2>
            <p id="distanceMiles">0.000</p>
        </div>

        <div class="metric">
            <h2>Calories Burned (kcal)</h2>
            <p id="caloriesBurned">0</p>
        </div>

        <div class="buttons">
            <button id="startButton">START</button>
            <button id="resetButton">RESET</button>
        </div>
        <p id="permissionMessage"></p>
    </div>

    <script>
        const stepCountElement = document.getElementById('stepCount');
        const distanceKmElement = document.getElementById('distanceKm');
        const distanceMilesElement = document.getElementById('distanceMiles');
        const caloriesBurnedElement = document.getElementById('caloriesBurned');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const permissionMessageElement = document.getElementById('permissionMessage');

        let steps = 0;
        let isCounting = false;
        let lastAcceleration = { x: null, y: null, z: null };
        let stepThreshold = 1.2; // Sensitivity: lower is more sensitive, higher is less. Tune this.
        let lastStepTime = 0;
        const stepDebounceTime = 300; // milliseconds to wait between potential steps to avoid double counting

        // Average stride length: 0.762 meters for men, 0.67 meters for women. Using an average.
        const averageStrideLengthMeters = 0.7;
        const metersToKm = 0.001;
        const metersToMiles = 0.000621371;

        // Average calories burned per step: This is highly variable.
        // A common estimate is 0.04 kcal per step for a 150lb person.
        const caloriesPerStep = 0.04;

        function updateDisplay() {
            stepCountElement.textContent = steps;

            const distanceMeters = steps * averageStrideLengthMeters;
            const distanceKm = distanceMeters * metersToKm;
            const distanceMiles = distanceMeters * metersToMiles;
            const calories = steps * caloriesPerStep;

            distanceKmElement.textContent = distanceKm.toFixed(3);
            distanceMilesElement.textContent = distanceMiles.toFixed(3);
            caloriesBurnedElement.textContent = Math.round(calories);
        }

        function resetAll() {
            steps = 0;
            lastAcceleration = { x: null, y: null, z: null };
            lastStepTime = 0;
            updateDisplay();
            permissionMessageElement.textContent = '';
        }

        resetButton.addEventListener('click', () => {
            if (confirm("Are you sure you want to reset all data?")) {
                if (isCounting) {
                    stopCounting(); // Stop listening to events if counting
                }
                resetAll();
            }
        });

        function handleMotionEvent(event) {
            if (!isCounting) return;

            const currentTime = new Date().getTime();
            if (currentTime - lastStepTime < stepDebounceTime) {
                return; // Debounce to prevent rapid multi-counts
            }

            const acceleration = event.accelerationIncludingGravity;
            if (!acceleration || acceleration.x === null || acceleration.y === null || acceleration.z === null) {
                // Fallback for browsers that don't provide accelerationIncludingGravity or return null values
                // This is less reliable as it doesn't easily filter out gravity
                // For a robust solution, one might need to implement a high-pass filter
                // or use event.acceleration if available and makes sense for the use case.
                // For simplicity, if accelerationIncludingGravity is problematic, this example
                // might not perform well.
                console.warn("Acceleration data is null or not available. Step detection may be unreliable.");
                // Try event.acceleration (without gravity) if available, though it's often less suitable directly
                // const accNoGravity = event.acceleration;
                // if (accNoGravity && accNoGravity.x !== null) { /* process accNoGravity */ }
                return;
            }


            if (lastAcceleration.x !== null) {
                const deltaX = Math.abs(acceleration.x - lastAcceleration.x);
                const deltaY = Math.abs(acceleration.y - lastAcceleration.y);
                const deltaZ = Math.abs(acceleration.z - lastAcceleration.z);

                // Simple peak detection: if the change in acceleration is significant on any axis
                // This is a very basic step detection algorithm and can be improved.
                // A more robust method would involve analyzing patterns, magnitudes, and frequencies.
                const magnitude = Math.sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);

                // Heuristic: A step often causes a noticeable jolt.
                // The threshold value 'stepThreshold' is critical and may need tuning.
                // It represents the magnitude of acceleration change considered a step.
                if (magnitude > stepThreshold) {
                    steps++;
                    lastStepTime = currentTime;
                    updateDisplay();
                }
            }
            lastAcceleration = { x: acceleration.x, y: acceleration.y, z: acceleration.z };
        }


        function requestMotionPermission() {
            // For iOS 13+
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', handleMotionEvent);
                            permissionMessageElement.textContent = "Motion tracking active.";
                            isCounting = true;
                            startButton.textContent = "STOP";
                        } else {
                            permissionMessageElement.textContent = "Permission for motion sensors denied.";
                            isCounting = false;
                            startButton.textContent = "START";
                        }
                    })
                    .catch(error => {
                        console.error("Error requesting motion permission:", error);
                        permissionMessageElement.textContent = "Could not request motion permission.";
                        isCounting = false;
                        startButton.textContent = "START";
                    });
            } else {
                // For other browsers (Android, older iOS)
                // Check if we already have permission or if it's granted by default (less common now)
                // The event listener itself will often trigger a permission prompt if needed
                // or work if permission is already granted.
                try {
                    window.addEventListener('devicemotion', handleMotionEvent);
                    // Attempt to add listener. If it fails silently or prompts, that's the browser behavior.
                    // We assume it works or will prompt. A more robust check isn't straightforward.
                    isCounting = true;
                    startButton.textContent = "STOP";
                    permissionMessageElement.textContent = "Attempting to track motion. Check browser prompts if any.";
                    // A small timeout to see if an event fires; if not, it might indicate no permission or no sensor.
                    // This is a heuristic.
                    setTimeout(() => {
                        if (isCounting && lastAcceleration.x === null) {
                             // Check if any motion data has been received
                            const testMotion = (e) => {
                                if (e.accelerationIncludingGravity && e.accelerationIncludingGravity.x !== null) {
                                    permissionMessageElement.textContent = "Motion tracking active.";
                                } else {
                                    permissionMessageElement.textContent = "Motion tracking might not be supported or is blocked.";
                                }
                                window.removeEventListener('devicemotion', testMotion, {once: true});
                            };
                            window.addEventListener('devicemotion', testMotion, {once: true});
                        }
                    }, 1000);


                } catch (error) {
                    console.error("Error adding devicemotion listener:", error);
                    permissionMessageElement.textContent = "Motion sensors not supported or access denied.";
                    isCounting = false;
                    startButton.textContent = "START";
                }
            }
        }

        function startCounting() {
            if (window.DeviceMotionEvent) {
                requestMotionPermission();
            } else {
                permissionMessageElement.textContent = "Motion sensors not supported on this device/browser.";
                isCounting = false;
                startButton.textContent = "START";
            }
        }

        function stopCounting() {
            window.removeEventListener('devicemotion', handleMotionEvent);
            isCounting = false;
            startButton.textContent = "START";
            lastAcceleration = { x: null, y: null, z: null }; // Reset last acceleration
            permissionMessageElement.textContent = "Motion tracking stopped.";
        }

        startButton.addEventListener('click', () => {
            if (!isCounting) {
                startCounting();
            } else {
                stopCounting();
            }
        });

        // Initialize display
        updateDisplay();

    </script>
</body>
</html>